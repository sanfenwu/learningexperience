#第十一期
##MQ中间件
**1、kafka**
    
    1、高吞吐量、分布式、基于发布订阅的消息系统。
    2、broker：kafka服务器，负责消息的存储和转发
    3、topic：消息类别，kafka按照topic来分类消息
    4、offset：消息在日志中的位置，可以理解是消息在partition上的偏移量，也是代表该消息的唯一序号
    5、producer：消息生产者
    6、consumer：消息消费者
    7、consumerGroup：消费者组，每个conseumer必须属于一个group
    8、Zookper：保存着集群broker、topic、partition等meta数据，另外，还负责broker故障发现，partitionleader选举，负载均衡功能
    9、同一个topic通过随机或是轮询hash分发到不同的分区（partition）
![](/image/kafka1.png)

**2、kafka维护消息状态跟踪方法**  

    1、大部分是维护消息状态，broker已经发送，或是consumer已处理后，但是都会有相应的问题
    2、kafka通过offset一个简单的整数，标记消息消费的位置，通过调整offset的值可以去消费一个较老的值
**3、数据传输的事务定义有哪三种**

    1、最多一次
    2、最少一次（并对消息设置唯一主键进行区分避免重复消费）
    3、就一次
**4、ack机制**  

    1、0：生产者不等待broker的ack，延迟低但是安全性差
    2、1：producer只要接受到一个leader的分区副本成功写入的ack就认为推送成功
    3、-1：producer接收到分区内所有副本成功写入的ack，才认为消息推送成功
**5、手动提交偏移量**    
    
    将 auto.commit.offset 设为 false，然后在处理一批消息后 commitSync() 或者异步提交 commitAsync()  
**6、如何保证消息不被重复消费**     
     
    幂等性：用户对一个请求发起多次结果是一样的
    保证幂等：通过对消息设置唯一id进行判断再决定是否消费
**7、rabbitMQ**
![](/image/rabbitMQ1.png)

    rabbitMQ的模式
    1、简单模式：一个生产者一个消费者
    2、work模式： 
    （1）、一个生产者，多个消费者，消费者接受到的消息是不同的；
    （2）、普通的work模式采用轮询的方式向不同的消费者发送消息；
    （3）、“能者多劳”的work模式采用回复确认机制，将消息置为手动确认模式，且将预置队列数为1（prefetchCount=1）；
        一个消费者接收到一条消息，直到处理成功确认后才会收到第二条消息；即处理能力强的消费者将接收更多的消息。
    3、fanout模式（发布订阅）：
    （1）、一个生产者，一个交换机，多个队列，多个消费者，一个消息经过队列后只能被一个消费者获取，所以每个消费者都配备了队列；
    （2）、生产者生成消息后，将由交换机分发到多个队列，队列再将消息传递给后方的消费者。
    （3）、一个消息可以被分发给多个消息队列，所以可以达到一个消息被多个消费者消费的目的。
    4、路由模式：
    （1）、一个生产者，一个交换机，多个队列，多个消费者；与订阅模式类似，不同之处在于消息带有类型，不同的消费者可以订阅不同类型的消息；
    （2）、（消息可以自定义类型，例如“update”、“create”、“delete”、“audit.irs.corporate”等）
    （3）、消息在经过交换机时，根据消息的类型进行路由，从而被分发到不同的队列中； 
    5、主题模式：
    （1）、一个生产者，一个交换机，多个队列，多个消费者；与路由模式类似，不同之处在于，其可以通过简单通配符的方式进行消息路由
        （如“#”表示所有消息类型，“*”表示单一词匹配）；
    （2）、例如：“audit.irs.corporate”消息，“audit.#”可以匹配到，但“audit.*”只能匹配“audit.irs”消息。
    6、rpc模式：
    （1）、客户端去调用远程服务器的某个功能，将所需要的数据传递过去，服务器端接受数据后去实现该功能，并将该功能的结果返回给客户端去处理，
    可以跨语言调用。
**8、rabbitMQ如何确保消息的正确传输**    

    （1）、发送方确认模式
    将信道设置成confirm模式，则所有在信道上发布的消息会被指派一个唯一ID，
    一旦消息被投递到目的队列后，或者消息被写入磁盘，信道会发送一个确认给生产者（包含唯一id）
    如果rabbitmq发生内部错误从而导致消息的丢失，会发送一条nack消息，消息的确认是异步的
    （2）、接收方确认机制
    消费者接受每一条消息后都必须进行确认，只有消费者确认了消息，rabbitmq才能安全的把消息从队列删除，这里没有超时
    只要连接不中断就一直等待，足够的时间保证数据最终一致性
**9、rabbitmq如何避免消息重复投递和消费**
    
    在生产消息时，MQ内部针对每条消息生成一个inner-msg-id，作为去重依据，避免消息重复进入队列
    在消费消息时，要求消息中必须有一个唯一标识，作为去重依据，避免同一条消息被重复消费
              
                
           
       
   

      

    