#第七期
##JVM
**1、JVM内存模型**
        
        主内存和线程独有内存
**2、逃逸分析**

        逃逸分析的基本行为是分析对象动态作用域
            （1）、当一个对象在一个方法中被定义了，对象只在方法内部使用，则认为没有发生逃逸
            （2）、当一个对象在方法中被定义后，他被外部方法所引用，则认为发生逃逸，例如作为参数传递到其他方法中，
            或者作为返回值
**3、八大原子操作**            
    注意：被弃用
    
    lock->read->load->use
    unlock<-write<-store<-assign   
    (1)、lock（锁定）：作用于主内存变量，把一个变量标记为一条线程独占状态
    (2)、unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来
    (3)、read（读取）：主要于主内存变量，把一个变量值从主内存传输到线程工作内存中
    (4)、load（载入）：作用于工作内存的变量，吧read操作从主内存中得到的变量值放入
    工作内存的变量副本中
    (5)、use（使用）：作用于工作内存的变量，把工作内存的变量传递给执行引擎
    (6)、assign（赋值）：作用于工作内存的变量，他把一个从执行引擎接收到的值赋给工作内存的变量
    (7)、store（存储）：作用于工作内存的变量，他把一个工作内存的变量的值传送到主内存中
    (8)、write（写入）：作用于工作内存变量，他把store操作从工作内存中的一个变量值传送到主内存的变量中
**4、锁和mark word关系**   
java五种不同状态下Mark Word的表现形式
                
![](/image/suo.png)
    
    一个java对象包括：对象头、实例数据、对其填充（8的倍数）
    (1)、偏向锁：一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，降低了获取锁的代价，
        markWord会记录偏向锁的线程ID，即偏向锁位
    (2)、轻量级锁：
        a、当有两个线程开始竞争这个锁对象时，锁升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象
        MarkWord就指向哪个线程的栈帧中的锁记录；
        b、当所处于偏向锁，又被另一个线程企图抢占时，偏向锁会升级为轻量级锁，企图抢占的线程通过自旋的形式抢占锁
        不会阻塞抢锁线程；
        c、持有锁的线程在很短时间内释放锁资源，等待线程就不需要进行内核态和用户态的切换，自旋获得锁对象减少了
        切换的消耗，
        d、不会一直自旋，他有周期适应性自旋锁就是自旋时间不固定，前一次自旋成功则下一次时间就长，前一次自旋
        失败则短
        
    (3)、重量级锁：
        a、如果持有锁线程执行时间超过自旋时间，自旋就不会一直持续，膨胀成重量级锁
        b、重量级锁也叫同步锁，MarkWord再次发生变化，会指向监视器对象，该监视器对象用集合的形式来登记和管理
        排队的线程
    (4)、公平锁/非公平锁：
        a、公平锁：先来先获得锁，队列中的第一个线程来获取
        b、非公平锁：一般不设置排队等待，每个线程只要当下锁可用，就有机会获取锁
    (5)、可重入锁/不可重入
        a、可重入锁：指同一个线程，当其外部方法获取锁后，内部方法可以获取同一把锁，而不是竞争和阻塞
        多次调用获得锁后也要多次解锁（synchronized、ReenTrantLock同一线程每进入一次，锁的计算器
        都自增1，要等到锁的计数器下降为0时才能释放锁）。
**5、jvm调优步骤**         
    
    1、cup使用率飙高
    分析：有线程长时间占用系统资源不进行释放，定位具体线程
    （1）、使用jps查看进程的pid
    （2）、top -Hp pid查看该进程各个线程信息中的cpu使用情况
    （3）、jstack pid打印线程信息，关注waiting 状态，waiting on 的内容（等待的线程）
    根据对应的线程号找到对应的线程，去找看线程的问题
    2、内存飙高问题
    分析：堆中对象无法回收，java对象大部分存储在堆内存中oom问题
    （1）、jinfo 列举jvm相关信息
    （2）、jstat -gc pid ms ：多长时间打印一次gc信息
    （3）、jmap -histo pid | head 20：查询当前进程堆中对象信息
**6、实例属性赋值时机**

    1、final修饰的实例属性，在实例创建的时候才会赋值
    2、static修饰的属性类，在类加载的准备阶段赋初值，初始化阶段赋值
    3、static final 修饰的String类型或者基本类型常量，jvm规范是在初始化阶段，但是hotspot VM直接在准备
    阶段就赋值了
    4、static final 修改引用类型常量，同2
          
                
           
       
   

      

    