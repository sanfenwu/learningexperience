#第二期
##基础
###1、reids持久化
rdb/aof:

    1、aof如果没有初始化，如果存在就读取
    2、redis接收指令，每个指令添加aof文件，当文件大小达到一定大小时rewrite
    或者手动调用bgrewriteaof
    3、fork出一个子进程，而父进程继续接受命令，现在所写的指令放在aof_rewrite_buf_block缓冲中
    4、当子进程rewrite结束后，父进程今收到子进程的信号，将缓冲中的内容添加到文件中，切换aof文件的fd。（先写临时文件最后rename）
###2、redis跳表
是一种有序的数据结构，通过每个节点指向其他节点的指针，打到快速访问节点的目的
![跳表](/image/skipList.png)
###3、aqs（abstractQueuedSynchronizer）及原理
        1、是juc（java.util.concurrent）下lock包里的类，实现了FIFO的队列（先进先出），底层是双向链表。
        里面有state变量、加锁线程变量等核心，维护了加锁状态，因为他可以判断当前加锁的线程是自己，所以可重入
        2、AQS中提供两套锁机制：共享锁与独占锁
        （1）、共享锁：多线程同时执行，线程执行个数受到state限制
        （2）、独占锁：当前只有一个线程能够运行reentrantlock
            a、公平锁：所有线程严格按照FIFo占有锁
            b、非公平锁：每个线程不管是否有等待线程等待，都会先尝试抢占锁，抢占锁失败再去clh队列等待锁资源释放
###4、synchronized和lock区别
        1、lock是一个接口，Synchronized是java关键字，synchronized是内置语言实现的。
        2、Synchronized，异常释放锁，不会死锁。lock异常不会释放锁，需要手动lock
        3、lock锁可以在程序过程中用interrupt来终端等待，Synchronized只能等待锁的释放，不能相应中断
        4、trylock可以知道是否获取到锁的情况
        5、synchronized可以作用到方法、代码块，lock一般加在代码块上
        6、锁类型，lock通过cas实现的乐观锁，Synchronized则是使用操作系统互斥量实现的悲观锁
###5、juc下常见的包
    atomic、locks、concurrentHashMap、CopyOnWriteArrayList\Executor
###6、io模型
|名称|阻塞|同步（1）/异步（0）|模型名称| 
|---|---|---|---|
|BIO|√|1|同步阻塞|
|NIO|×|1|同步非阻塞|
|io多路复用|√|1|同步阻塞|
|信号驱动io|×|1| 同步非阻塞|
|AIO|错|0|异步非阻塞|
###7、tcp三次握手四次挥手以及各个时期的状态
![tcp协议](/image/tcp.jpeg)
###8、

      

    