#第五期
##算法
###1、顺序查找
        
        顾名思义循环一个一个对比查找
###2、二分查找

        定义起、中、尾三个位置，校验目标值和中间位置的值是否相等，改变起尾位置循环处理
        注意：二分查找需要原本容器内的元素有序
##排序
###1、直接选择排序
        每次大循环只找出一个最值然后交换位置
        每次小循环值对最值的索引位置进行改变，最后进行交换位置
###2、冒泡排序 
        每次大循环找出一个最值，但是经过多次交换
        每次小循环对相邻的进行比较交换位置
###3、插入排序
        大循环：从第二个开始取值，和第一个比较
        小循环：拿后面无序的一个数和前面有序的一个元素比较互换
###4、快速排序
        拿出来一个参照值挖出来作为第一个坑
        依次比这个数大的放在右边，比这个数小的放在左边
        注意：一次处理确定基准值的位置并将数据进行分区
###5、链表反转

    public ListNode reverseList(ListNode head){
    
       public ListNode retHead=null;//最终返回的头结点（代理节点）
       public ListNode curHead=head;//现在的头结点
       //思路:循环取下一个节点，并设置next（前一个节点）
       while（curHead ！=null）{
            //获得当前的下一个节点
            ListNode next=curHead.next;
            //给当前节点设置新的next节点
            curHead.next(retHead);
            //代理节点设置新的值
            retHead=curHead;
            //设置新的当前节点
            curHead=next;
       
       }
       retrun retHead;
    }
        
               
              

            



               
                
           
       
   

      

    