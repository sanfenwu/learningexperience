#第三期
##volatile与CAS
**1、保障可见性**
 ![volatile](/image/volatile.png)
多个线程间对，同一个变量操作时是可见的  
**2、禁止指令重排序**
![volatile](/image/volatile2.png)
并发执行指令的时候，在申请内存为默认值0的时候被调走，加了volatile后不会出现指令重排  
**3、CAS（无锁优化 自旋）**  
想要改变一个值从0变为1，我们一般需要加锁，来保证线程安全。cas是一种思想，当成一种方法
cas（‘待改变值oldvalue’，‘预期值value’，‘新值newvalue’）判断oldvalue和value
是否相等，相等则处理，否则更改预期值重试，直至成功  
**4、ABA问题**
考虑具体的业务，如果是基本的数据类型，可以不考虑这种业务，引用类型下，则可以考虑添加版本号  
**5、双重检查锁**

        public class SingLeton{
            private volatile static SingLeton singleton；
            private SingLeton（）{}
            public SingLeton getInstace(){
            //1、第一次检查判断为空如果不为空则不加锁直接返回
                if(singleton==null){
                synchronized(SingLeton.class){
                //2、第二次检查判断为空，因为在第一次判断为空时可能有多个线程进来等待锁，
                //避免第二个线程来的时候创建线程
                if(singleton==null){
                    singleton=new Singleton();
                }
                }
                }
            retrun singleton;
            }
        
        }
**6、线程安全三要素（JMM特点）**      
`原子性、可见性、有序性`         
**7、方法notify、notifyAll、wait**  
`对象中的方法，释放锁、加锁针对对象的，释放锁，锁等待`  
**8、String、StringBuffer、Stringbuilder的区别**  
`使用+和concat字符串拼接的时候会new对象，所以使用StringBuilder。append（）方法`
 
      a、string不可变
      b、StringBuffer重安全轻效率
      c、Stringbuilder重效率轻安全
**9、aqs（abstractQueuedSynchronizer）及原理**
        
        1、AQS是一个同步器，要做的事情相当于一个锁，所以会有两个动作：一个获取，一个释放
        需要一个标志是否被用，如果被获取了再有其他的，需要排队，有一个队列。
        2、AQS的核心思想：通过一个volatile修饰的int属性state代表同步状态，例如0是无锁，1是上锁状态
        多线程竞争资源时，通过CAS的方式修改state，修改成功的线程则代表竞争资源成功的线程，竞争失败的则放在（CLS=）FIFO队列
        3、是juc（java.util.concurrent）下lock包里的类，实现了FIFO的队列（先进先出），底层是双向链表。
        里面有state变量、加锁线程变量等核心，维护了加锁状态，因为他可以判断当前加锁的线程是自己，所以可重入
        4、AQS中提供两套锁机制：共享锁与独占锁
        （1）、共享锁：多线程同时执行，线程执行个数受到state限制
        （2）、独占锁：当前只有一个线程能够运行reentrantlock
            a、公平锁：所有线程严格按照FIFo占有锁
            b、非公平锁：每个线程不管是否有等待线程等待，都会先尝试抢占锁，抢占锁失败再去clh队列等待锁资源释放
**10、synchronized和lock区别**
        
        1、lock是一个接口，Synchronized是java关键字，synchronized是内置语言实现的。
        2、Synchronized，异常释放锁，不会死锁。lock异常不会释放锁，需要手动lock
        3、lock锁可以在程序过程中用interrupt来终端等待，Synchronized只能等待锁的释放，不能相应中断
        4、trylock可以知道是否获取到锁的情况
        5、synchronized可以作用到方法、代码块，lock一般加在代码块上
        6、锁类型，lock通过cas实现的乐观锁，Synchronized则是使用操作系统互斥量实现的悲观锁
**11、juc下常见的包**
    
    atomic、locks、concurrentHashMap、CopyOnWriteArrayList\Executor

**12、什么是cpu密集型？什么是io密集型**    

     1、cpu密集型：也叫计算密集型，cpu使用率高，读、写I/O,很短时间内完成，线程数为核数即可
     2、I/O密集型：大部分时间cpu在等待I/O的读写操作，导致cpu使用率低，线程数为等待数/cpu处理时间+1
**13、线程池的数量和cpu核数的关系**
    
    1、cpu密集型，尽量使用较小的线程池，一般为cpu核心数+1
    因为cpu密集型任务使得cpu使用率很高，若开过多的线程数会增加上下文切换的次数，因此会带来额外的开销。
    2、IO密集型任务
    可以使用稍大的线程池，一般为2*cpu数
    因为IO密集型cpu使用率不高，因此可以让cpu在等待IO的时候去处理别的任务，充分利用cpu时间
    3、混合型任务
    可以将任务分成IO密集型，和cpu密集型，然后分别用不同的线程池处理，只要分完之后两个任务的执行时间差不多
    就会比串行执行来的高效
**14、线程、进程、并行、并发**    

注意：需要在多核cpu才能提高效率，单核仍然是轮流执行
    
    1、进程：
    （1）、程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至cpu，数据加载到内存，
    指令执行期间还需要磁盘和网络等设备，进程就是用来加载指令，管理内存，管理IO的
    （2）、当一个程序被运行，代码从磁盘加载到内存中，即开启了一个进程
    （3）、进程可以视为一个程序的实例，大部分程序可以同时运行多个实力进程
    2、线程：
    （1）、一个进程内分为一个或多个线程
    （2）、一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给cpu执行
    （3）、java中线程是最小的调度单位，进程是资源分配的最小单位，在windows中进程不活动，是线程的容器
    3、比较：
    （1）、进程基本上相互独立，而线程存在于进程内，是进程的子集
    （2）、进程拥有共享资源，如内存空间，供其内部的线程共享
    （3）、进程间通信比较复杂
    （4）、线程通信先对简单，共享线程内的内存，多线程访问同一个共享变量
    （5）、线程更轻量，线程上下文切换成本一般比进程上下文切换低
    4、并发：同一时间应对多件事情的能力
    （1）、单核cpu下，线程实际还是串行执行的，操作系统中有个组件叫任务调度器，将cpu的时间片（15us）分给
    不同的程序使用，cpu在线程间的切换非常快，感觉上是同时运行，将这种线程轮流使用cpu的做法成为称为并发
    5、并行：同一时间做多件事情的能力
    （1）、多核cpu下，每个核都可以调度运行线程，这时候线程可以是并行
**15、多任务调度**    

    1、操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下15ms）分给不同的程序使用，只是由于cpu
    在线时间的切换非常快，给人的感觉是同时运行
    2、线程阻塞状态：
    (1)、如果调用了阻塞api，如BIO读写文件时，这时该线程实际上使用的事io资源，不会用到cpu，会导致
    线程上下文切换，进入阻塞状态
    (2)、等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态(可以被调度器调用)
**16、线程锁**    

    1、死锁：两个或两个以上的进程在执行过程中，由于资源竞争或者由于彼此通信而造成的一种阻塞现象
    条件
    （1）、互斥使用：即当一个资源被一个线程占用时，其他线程不能使用
    （2）、不可占用：只能拥有者自己释放
    （3）、请求和保持：在请求其他资源的时候同时保持对原有资源的占有
    （4）、循环等待：等待呈环形
    2、活锁：
    当两个线程或想改变对方的结束条件，最后谁都无法结束
    3、饥饿：一个线程由于优先级太低，始终得不到cpu调起


