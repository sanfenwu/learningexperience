#第三期
##volatile与CAS
**1、保障可见性**
 ![volatile](/image/volatile.png)
多个线程间对，同一个变量操作时是可见的  
**2、禁止指令重排序**
![volatile](/image/volatile2.png)
并发执行指令的时候，在申请内存为默认值0的时候被调走，加了volatile后不会出现指令重排  
**3、CAS（无锁优化 自旋）**  
想要改变一个值从0变为1，我们一般需要加锁，来保证线程安全。cas是一种思想，当成一种方法
cas（‘待改变值oldvalue’，‘预期值value’，‘新值newvalue’）判断oldvalue和value
是否相等，相等则处理，否则更改预期值重试，直至成功  
**4、ABA问题**
考虑具体的业务，如果是基本的数据类型，可以不考虑这种业务，引用类型下，则可以考虑添加版本号  
**5、双重检查锁**

        public class SingLeton{
            private volatile static SingLeton singleton；
            private SingLeton（）{}
            public SingLeton getInstace(){
            //1、第一次检查判断为空
                if(singleton==null){
                synchronized(SingLeton.class){
                //2、第二次检查判断为空，因为在第一次判断为空时可能有多个线程进来等待锁，
                //避免第二个线程来的时候创建线程
                if(singleton==null){
                    singleton=new Singleton();
                }
                }
                }
            retrun singleton;
            }
        
        }
**6、线程安全三要素**      
`原子性、可见性、有序性`         
**7、方法notify、notifyAll、wait**  
`对象中的方法，释放锁、加锁针对对象的，释放锁，锁等待`  
**8、String、StringBuffer、Stringbuilder的区别**  
`使用+和concat字符串拼接的时候会new对象，所以使用StringBuilder。append（）方法`
 
      a、string不可变
      b、StringBuffer重安全轻效率
      c、Stringbuilder重效率轻安全


